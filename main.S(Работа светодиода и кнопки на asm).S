.equ PIN_LED,                     7              # Определяет номер вывода для светодиода (PORT_2_7)
.equ PIN_BUTTON,                  6              # Определяет номер вывода для кнопки (PORT_2_6)
.equ GPIO_BASE,                   (0x00084800)   # Базовый адрес регистров GPIO
.equ PM_CLK_APB_P_SET,           (0x000050000) + (0x1C) # Адрес регистра тактирования для GPIO
.equ GPIO_DIRECTION,              (GPIO_BASE + 0x08) # Адрес регистра направления GPIO
.equ DIRECTION_IN,                (0x0C)         # Константа для указания входного направления
.equ GPIO_DIRECTION_IN,           (GPIO_BASE + DIRECTION_IN) # Адрес регистра направления входа GPIO
.equ GPIO_OUTPUT,                 (GPIO_BASE + 0x10) # Адрес регистра выходного состояния GPIO

.equ PAD_CONFIG_BASE_ADDRESS,     (0x000050C00)   # Базовый адрес конфигурации порта
.equ PORT_2_CFG,                  (0x18)           # Смещение для конфигурации порта 2
.equ PAD_CONFIG_PORT_2_CFG,       (PAD_CONFIG_BASE_ADDRESS + PORT_2_CFG)  # Адрес конфигурации порта 2

.section .text                     # Начало секции кода
.globl _start                      # Глобальная метка для точки входа

_start:                           # Точка входа в программу
    jal init_gpio                 # Вызов функции инициализации GPIO
    jal loop_main                 # Переход к основному циклу программы

init_gpio:                       # Функция инициализации GPIO
    # Включаем тактирование GPIO
    li t0, PM_CLK_APB_P_SET      # Загружаем адрес регистра тактирования
    lw t1, 0(t0)                 # Читаем текущее значение регистра
    li t2, (1 << 14)             # Подготавливаем бит для включения тактирования GPIO
    or t1, t1, t2                 # Устанавливаем соответствующий бит
    sw t1, 0(t0)                 # Записываем новое значение обратно в регистр

    # Настраиваем порты
    lui t0, %hi(GPIO_BASE)       # Загружаем верхнюю часть адреса GPIO
    addi t0, t0, %lo(GPIO_BASE)  # Собираем полный адрес GPIO
    li t1, (1 << PIN_LED) | (1 << PIN_BUTTON) # Создаем маску для светодиода и кнопки
    sw t1, 0(t0)                 # Очищаем биты для LED и кнопки (устанавливаем их как INPUT)

    # Добавляем конфигурацию порта 2
    lui t0, %hi(PAD_CONFIG_PORT_2_CFG) # Загружаем верхнюю часть адреса конфигурации порта 2
    addi t0, t0, %lo(PAD_CONFIG_PORT_2_CFG)  # Собираем полный адрес
    li t1, 0x00000000            # Устанавливаем необходимую конфигурацию (например, все поля в 0)
    sw t1, 0(t0)                 # Записываем конфигурацию в регистр порта

    # Установить направление GPIO как вход для кнопки
    li t0, GPIO_DIRECTION_IN      # Загрузка адреса регистра направления для входа GPIO
    li t1, (0 << PIN_BUTTON)      # Устанавливаем BUTTON как вход (бит = 0)
    sw t1, 0(t0)                  # Устанавливаем направление для кнопки

    # Устанавливаем LED как выход
    li t0, GPIO_DIRECTION          # Получаем адрес регистра направления GPIO
    li t1, (1 << PIN_LED)         # Устанавливаем LED как выход (бит = 1)
    sw t1, 0(t0)                  # Записываем направление для LED

    ret                            # Возврат из функции инициализации

loop_main:                       # Основной цикл программы
    # Проверка состояния кнопки
    lui t0, %hi(GPIO_BASE)           # Загружаем верхнюю часть адреса GPIO
    addi t0, t0, %lo(GPIO_BASE)      # Собираем полный адрес GPIO
    lw t1, 0(t0)                     # Читаем текущее состояние кнопки
    andi t1, t1, (1 << PIN_BUTTON)   # Проверяем, нажата ли кнопка (носим 1 если кнопка нажата так как пин 0 активен)

    # Если кнопку не нажата, устанавливаем светодиод в HIGH
    beqz t1, led_on                 # Если кнопка не нажата (t1 == 0), переходим к led_on метке

    # Если кнопка нажата, мигаем светодиодом
    li t0, GPIO_OUTPUT              # Загружаем адрес выхода GPIO
    lw t1, 0(t0)                   # Читаем текущее значение выхода
    xor t1, t1, (1 << PIN_LED)     # Переворачиваем состояние LED (включаем/выключаем)
    sw t1, 0(t0)                   # Записываем новое состояние

    jal sleep                       # Вызов функции задержки
    j loop_main                     # Возвращаемся в основной цикл

led_on:                           # Метка когда кнопка не нажата
    # Если кнопка не нажата, устанавливаем светодиод в HIGH
    li t0, GPIO_OUTPUT              # Загружаем адрес выхода GPIO
    li t1, (1 << PIN_LED)           # Устанавливаем LED в HIGH
    sw t1, 0(t0)                   # Записываем новое значение LED
    j loop_main                     # Возвращаемся в основной цикл

sleep:                           # Функция задержки
    li a0, 1000000                 # Задаем значение задержки
sleep_loop:                      # Метка начала цикла задержки
    addi a0, a0, -1                # Уменьшаем счетчик задержки
    bnez a0, sleep_loop            # Если счетчик не 0, продолжаем ждать

    ret                            # Возврат из функции задержки
    